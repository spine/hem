// Generated by CoffeeScript 2.7.0
(function() {
  var Application, CssPackage, Dependency, JsPackage, Package, Stitch, TestPackage, _argv, _hem, create, events, fs, log, path, uglifycss, uglifyjs, utils, versioning;

  fs = require('fs-extra');

  path = require('path');

  uglifyjs = require('uglify-js');

  uglifycss = require('uglifycss');

  Dependency = require('./dependency');

  Stitch = require('./stitch');

  utils = require('./utils');

  events = require('./events');

  log = require('./log');

  versioning = require('./versioning');

  // ------- Variables set by hem during startup
  _hem = void 0;

  _argv = void 0;

  // ------- Application Class
  Application = class Application {
    constructor(name, config = {}) {
      var defaults, err, key, loadedDefaults, packager, ref, route, value, verType;
      this.name = name;
      this.route = config.route;
      this.root = config.root;
      // apply defaults
      if (config.defaults) {
        try {
          // make sure we don't modify the original assets (which is cached by require)
          loadedDefaults = utils.loadAsset('defaults/' + config.defaults);
          defaults = utils.extend({}, loadedDefaults);
        } catch (error) {
          err = error;
          log.error("ERROR: Invalid 'defaults' value provided: " + config.defaults);
          process.exit(1);
        }
        // create updated config mapping by merging with default values
        config = utils.extend(defaults, config);
      }
      // set root variable
      if (!this.root) {
        // if application name is also a directory then assume that is root
        if (utils.isDirectory(this.name)) {
          this.root = this.name;
          this.route || (this.route = `/${this.name}`);
        } else {
          // otherwise just work from top level directory
          this.root = "/";
          this.route || (this.route = "/");
        }
      }
      // make sure route has a value
      this.static = [];
      this.packages = [];
      ref = config.static;
      // configure static routes with base root and route values
      for (route in ref) {
        value = ref[route];
        this.static.push({
          url: this.applyBaseRoute(route),
          path: this.applyRootDir(value)[0]
        });
      }
// configure js/css packages
      for (key in config) {
        value = config[key];
        packager = void 0;
        // determine package type
        if (key === 'js' || utils.endsWith(key, '.js')) {
          packager = JsPackage;
          value.name = key;
        } else if (key === 'css' || utils.endsWith(key, '.css')) {
          packager = CssPackage;
          value.name = key;
        }
        // add to @packages array
        if (packager) {
          this.packages.push(new packager(this, value));
        }
      }
      // configure test structure
      if (config.test) {
        config.test.name = "test";
        this.packages.push(new TestPackage(this, config.test));
      }
      // configure versioning
      if (config.version) {
        verType = versioning[config.version.type];
        if (!verType) {
          log.errorAndExit(`Incorrect type value for version configuration: (${config.version.type})`);
        }
        this.versioning = new verType(this, config.version);
      }
    }

    getTestPackage() {
      var i, len, pkg, ref;
      ref = this.packages;
      for (i = 0, len = ref.length; i < len; i++) {
        pkg = ref[i];
        if (pkg.constructor.name === "TestPackage") {
          return pkg;
        }
      }
    }

    isMatchingRoute(route) {
      var i, len, pkg, ref;
      // strip out any versioning applied to file
      if (this.versioning) {
        route = this.versioning.trim(route);
      }
      ref = this.packages;
      // compare against package route values
      for (i = 0, len = ref.length; i < len; i++) {
        pkg = ref[i];
        if (route === pkg.route.toLowerCase()) {
          return pkg;
        }
      }
    }

    // return nothing
    unlink() {
      var i, len, pkg, ref, results1;
      log(`Removing application: <green>${this.name}</green>`);
      ref = this.packages;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        pkg = ref[i];
        results1.push(pkg.unlink());
      }
      return results1;
    }

    build() {
      var i, len, pkg, ref, results1;
      log(`Building application: <green>${this.name}</green>`);
      ref = this.packages;
      results1 = [];
      for (i = 0, len = ref.length; i < len; i++) {
        pkg = ref[i];
        results1.push(pkg.build());
      }
      return results1;
    }

    watch() {
      var dirs, pkg;
      log(`Watching application: <green>${this.name}</green>`);
      dirs = (function() {
        var i, len, ref, results1;
        ref = this.packages;
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          pkg = ref[i];
          results1.push(pkg.watch());
        }
        return results1;
      }).call(this);
      // make sure dirs has valid values
      if (dirs.length) {
        return log.info(`- Watching directories: <yellow>${dirs}</yellow>`);
      } else {
        return log.info("- No directories to watch...");
      }
    }

    version() {
      log(`Versioning application: <green>${this.name}</green>`);
      if (this.versioning) {
        return this.versioning.update();
      } else {
        return log.errorAndExit("ERROR: Versioning not enabled in slug.json");
      }
    }

    applyRootDir(value) {
      var values;
      // TODO: eventually use the Hem.home directory value if the home
      // TODO: value is different from the process.cwd() value?!
      values = utils.toArray(value);
      values = values.map((value) => {
        if (utils.startsWith(value, "." + path.sep)) {
          return value;
        } else {
          return utils.cleanPath(this.root, value);
        }
      });
      return values;
    }

    applyBaseRoute(...values) {
      if (this.route) {
        values.unshift(this.route);
      }
      return utils.cleanRoute.apply(utils, values);
    }

  };

  Package = (function() {
    // ------- Package Classes
    class Package {
      constructor(app, config) {
        var i, len, ref, regexp, route, targetFile, targetUrl;
        this.app = app;
        this.name = config.name;
        this.src = this.app.applyRootDir(config.src || "");
        this.target = this.app.applyRootDir(config.target || "")[0];
        // determine target filename
        if (utils.isDirectory(this.target)) {
          // determine actual file name
          if (this.name === this.ext) {
            targetFile = this.app.name;
          } else {
            targetFile = this.name;
          }
          this.target = utils.cleanPath(this.target, targetFile);
        }
        // make sure correct extension is present
        if (!utils.endsWith(this.target, `.${this.ext}`)) {
          this.target = `${this.target}.${this.ext}`;
        }
        // determine url from configuration
        if (config.route) {
          if (utils.startsWith(this.target, "/")) {
            this.route = config.route;
          } else {
            this.route = this.app.applyBaseRoute(config.route);
          }
        } else {
          ref = this.app.static;
          // use the static urls to determine the package @route
          for (i = 0, len = ref.length; i < len; i++) {
            route = ref[i];
            if (!this.route) {
              if (utils.startsWith(this.target, route.path)) {
                regexp = new RegExp(`^${route.path.replace(/\\/g, "\\\\")}(\\\\|\/)?`);
                targetUrl = this.target.replace(regexp, "");
                this.route = utils.cleanRoute(route.url, targetUrl);
              }
            }
          }
        }
        // make sure we have a route to use when using server command
        if (_argv.command === "server" && !this.route) {
          log.errorAndExit(`Unable to determine route for <yellow>${this.target}</yellow>`);
        }
      }

      handleCompileError(ex) {
        // check for method on _hem to allow override of behavior
        if (_hem.handleCompileError) {
          _hem.handleCompileError(ex);
          return;
        }
        // TODO: construct better error message, one that works for all precompilers,
        log.error(ex.message);
        if (ex.path) {
          log.error(ex.path);
        }
        // only return when in server/watch mode, otherwise exit
        switch (_argv.command) {
          case "server":
            if (this.ext === "js") {
              return `alert(\"HEM: ${ex}\\n\\n${ex.path}\");`;
            } else {
              return "";
            }
            break;
          case "watch":
            return "";
          default:
            return process.exit(1);
        }
      }

      unlink() {
        if (fs.existsSync(this.target)) {
          log.info(`- removing <yellow>${this.target}</yellow>`);
          return fs.unlinkSync(this.target);
        }
      }

      build(file) {
        var dirname, extra, source, write;
        if (file) {
          // remove the files module from Stitch so its recompiled
          Stitch.clear(file);
        }
        // extrea logging
        extra = (_argv.compress && " <b>--using compression</b>") || "";
        log.info(`- Building target: <yellow>${this.target}</yellow>${extra}`);
        // compile source
        source = this.compile();
        // determine if we need to write to filesystem
        write = _argv.command !== "server";
        if (source && write) {
          dirname = path.dirname(this.target);
          if (!fs.existsSync(dirname)) {
            fs.mkdirsSync(dirname);
          }
          fs.writeFileSync(this.target, source);
        }
        return source;
      }

      watch() {
        var dir, dirs, fileOrDir, i, j, len, len1, ref, watchOptions;
        watchOptions = {
          persistent: true,
          interval: 1,
          ignoreDotFiles: true,
          maxListeners: 128
        };
        // get dirs to watch
        dirs = [];
        ref = this.getWatchedDirs();
        for (i = 0, len = ref.length; i < len; i++) {
          fileOrDir = ref[i];
          if (!fs.existsSync(fileOrDir)) {
            continue;
          }
          if (utils.isDirectory(fileOrDir)) {
            dirs.push(fileOrDir);
          } else {
            dirs.push(path.dirname(fileOrDir));
          }
        }
        dirs = utils.removeDuplicateValues(dirs);
// start watch process
        for (j = 0, len1 = dirs.length; j < len1; j++) {
          dir = dirs[j];
          require('watch').watchTree(dir, watchOptions, (f, curr, prev) => {
            if (typeof f === "object" && prev === null && curr === null) {
              return;
            }
            // f was changed
            // Finished walking the tree
            console.log('build', f);
            this.build(f);
            // emit watch event
            return events.emit("watch", this.app, this, f);
          });
        }
        // return dirs that are watched
        return dirs;
      }

      getWatchedDirs() {
        return this.src;
      }

    };

    Package.prototype.ext = "";

    return Package;

  }).call(this);

  JsPackage = (function() {
    // ------- Child Classes
    class JsPackage extends Package {
      constructor(app, config) {
        // call parent
        super(app, config);
        // javascript only configurations
        this.commonjs = config.commonjs || 'require';
        this.libs = this.app.applyRootDir(config.libs || []);
        this.modules = utils.toArray(config.modules || []);
        // javascript to add before/after the stitch file
        this.before = utils.arrayToString(config.before || "");
        this.after = utils.arrayToString(config.after || "");
      }

      compile() {
        var ex, result;
        try {
          result = [this.before, this.compileLibs(), this.compileModules(), this.after].join("\n");
          if (_argv.compress) {
            result = uglifyjs.minify(result).code;
          }
          return result;
        } catch (error) {
          ex = error;
          return this.handleCompileError(ex);
        }
      }

      compileModules() {
        var _modules;
        // TODO use detective to load only those modules that are required ("required")?
        // or use the modules [] to specifiy which modules if any to load? or
        // set to false to never load any node_modules even if they are required in
        // javascript files. Would have to determine files needed from the stitched
        // files first...

        // TODO: also for testing we can remove the specs that don't match and optional parameter
        this.depend || (this.depend = new Dependency(this.modules));
        this.stitch || (this.stitch = new Stitch(this.src));
        _modules = this.depend.resolve().concat(this.stitch.resolve());
        if (_modules) {
          return Stitch.template(this.commonjs, _modules);
        } else {
          return "";
        }
      }

      compileLibs(files = this.libs, parentDir = "") {
        var dir, file, i, len, ref, results, slash, stats;
        // TODO: need to perform similar operation as stitch in that only
        // compilable code is used... refactor Stitch class to handle this?? except
        // we don't want the code actually stitched in a template, just plain old js

        // check if folder or file
        results = [];
        for (i = 0, len = files.length; i < len; i++) {
          file = files[i];
          // treat as normal javascript string
          if (utils.endsWith(file, ";")) {
            results.join(file);
          } else {
            // else load as file/dir
            slash = parentDir === "" ? "" : path.sep;
            if (file.startsWith("_")) {
              // ignore files that start with "_", used for template files that process
              // includes (ex stylus), so they don't get compiled twice.
              continue;
            }
            // set full path for following code checks
            file = parentDir + slash + file;
            if (fs.existsSync(file)) {
              stats = fs.lstatSync(file);
              if (stats.isDirectory()) {
                dir = fs.readdirSync(file);
                results.push(this.compileLibs(dir, file));
              } else if (stats.isFile() && ((ref = path.extname(file)) === '.js' || ref === '.coffee')) {
                results.push(fs.readFileSync(file, 'utf8'));
              }
            }
          }
        }
        return results.join("\n");
      }

      getWatchedDirs() {
        return this.src.concat(this.libs);
      }

    };

    JsPackage.prototype.ext = "js";

    return JsPackage;

  }).call(this);

  TestPackage = class TestPackage extends JsPackage {
    constructor(app, config) {
      var ref;
      super(app, config);
      // test configurations
      this.depends = utils.toArray(config.depends);
      // get test home directory based on target file location
      this.testHome = path.dirname(this.target);
      this.framework = _hem.options.hem.test.frameworks;
      // test to make sure framework is set correctly
      if ((ref = this.framework) !== 'jasmine' && ref !== 'mocha') {
        log.errorAndExit(`Test frameworks value is not valid: ${this.framework}`);
      }
      // javascript to run at end of specs file
      this.after += `// HEM: load in specs from test js file
var onlyMatchingModules = \"${_argv.grep || ""}\";
for (var key in ${this.commonjs}.modules) {
  if (onlyMatchingModules && key.indexOf(onlyMatchingModules) == -1) {
    continue;
  }
  ${this.commonjs}(key);
}`;
    }

    build(file) {
      this.createTestFiles();
      return super.build(file);
    }

    getAllTestTargets(relative = true) {
      var dep, depapp, homeRoute, i, j, k, l, len, len1, len2, len3, pkg, pth, ref, ref1, ref2, ref3, relativeFn, targets, url;
      targets = [];
      homeRoute = path.dirname(this.route);
      // create function to determine route/path
      relativeFn = function(home, target, url = true) {
        var value;
        value = "";
        if (relative) {
          value = path.relative(home, target);
        } else {
          value = target;
        }
        if (url) {
          // deal with windows :o(
          return value.replace(/\\/g, "/");
        } else {
          return value;
        }
      };
      ref = this.depends;
      // first get dependencies
      for (i = 0, len = ref.length; i < len; i++) {
        dep = ref[i];
        ref1 = _hem.allApps;
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          depapp = ref1[j];
          if (depapp.name === dep) {
            ref2 = depapp.packages;
            for (k = 0, len2 = ref2.length; k < len2; k++) {
              pkg = ref2[k];
              if (pkg.constructor.name !== "JsPackage") {
                continue;
              }
              url = relativeFn(homeRoute, pkg.route);
              pth = relativeFn(this.testHome, pkg.target);
              targets.push({
                url: url,
                path: pth
              });
            }
          }
        }
      }
      ref3 = this.app.packages;
      // get app targets
      for (l = 0, len3 = ref3.length; l < len3; l++) {
        pkg = ref3[l];
        if (pkg.constructor.name !== "JsPackage") {
          continue;
        }
        url = relativeFn(homeRoute, pkg.route);
        pth = relativeFn(this.testHome, pkg.target);
        targets.push({
          url: url,
          path: pth
        });
      }
      // finally add main test target file
      url = relativeFn(homeRoute, pkg.route);
      pth = relativeFn(this.testHome, pkg.target);
      targets.push({
        url: url,
        path: pth
      });
      return targets;
    }

    getFrameworkFiles() {
      var file, frameworkPath, i, len, ref, ref1, targets, url;
      targets = [];
      frameworkPath = path.resolve(__dirname, `../assets/testing/${this.framework}`);
      ref = fs.readdirSync(frameworkPath);
      for (i = 0, len = ref.length; i < len; i++) {
        file = ref[i];
        if ((ref1 = path.extname(file)) === ".js" || ref1 === ".css") {
          url = `${this.framework}/${file}`;
          targets.push({
            url: url,
            path: url
          });
        }
      }
      return targets;
    }

    getTestIndexFile() {
      return path.resolve(this.testHome, 'index.html');
    }

    // TODO: only do this for browser tests???
    createTestFiles() {
      var file, filepath, files, frameworkPath, i, indexFile, len, ref, ref1, results1, template;
      // create index file and libs if they currently don't exist
      indexFile = this.getTestIndexFile();
      if (!fs.existsSync(indexFile)) {
        files = [];
        files.push.apply(files, this.getFrameworkFiles());
        files.push.apply(files, this.getAllTestTargets());
        template = utils.tmpl("testing/index", {
          commonjs: this.commonjs,
          files: files,
          before: this.before
        });
        fs.outputFileSync(indexFile, template);
        // copy the framework files if they aren't present
        frameworkPath = path.resolve(__dirname, `../assets/testing/${this.framework}`);
        ref = fs.readdirSync(frameworkPath);
        results1 = [];
        for (i = 0, len = ref.length; i < len; i++) {
          file = ref[i];
          if ((ref1 = path.extname(file)) === ".js" || ref1 === ".css") {
            filepath = path.resolve(this.testHome, `${this.framework}/${file}`);
            results1.push(utils.copyFile(path.resolve(frameworkPath, file), filepath));
          } else {
            results1.push(void 0);
          }
        }
        return results1;
      }
    }

  };

  CssPackage = (function() {
    class CssPackage extends Package {
      constructor(app, config) {
        super(app, config);
      }

      compile() {
        var ex, file, fileOrDir, i, j, len, len1, output, ref, ref1, requireCss, result;
        try {
          output = [];
          // helper function to perform compiles
          requireCss = function(filepath) {
            filepath = require.resolve(path.resolve(filepath));
            delete require.cache[filepath];
            return require(filepath);
          };
          ref = this.src;
          // loop over path values
          for (i = 0, len = ref.length; i < len; i++) {
            fileOrDir = ref[i];
            // if directory loop over all top level files only
            if (utils.isDirectory(fileOrDir)) {
              ref1 = fs.readdirSync(fileOrDir);
              for (j = 0, len1 = ref1.length; j < len1; j++) {
                file = ref1[j];
                if (!require.extensions[path.extname(file)]) {
                  continue;
                }
                file = path.resolve(fileOrDir, file);
                output.push(requireCss(file));
              }
            } else {
              output.push(requireCss(fileOrDir));
            }
          }
          // join and minify
          result = output.join("\n");
          if (_argv.compress) {
            result = uglifycss.processString(result);
          }
          return result;
        } catch (error) {
          ex = error;
          return this.handleCompileError(ex);
        }
      }

    };

    CssPackage.prototype.ext = "css";

    return CssPackage;

  }).call(this);

  // ------- Public Functions
  create = function(name, config, hem, argv) {
    _hem || (_hem = hem);
    _argv || (_argv = argv);
    return new Application(name, config);
  };

  module.exports.create = create;

}).call(this);
