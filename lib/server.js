// Generated by CoffeeScript 1.6.3
(function() {
  var checkForRedirect, connect, createRoutingProxy, fs, http, httpProxy, log, mime, patchServerResponseForRedirects, server, utils;

  connect = require('connect');

  mime = require('connect')["static"].mime;

  httpProxy = require('http-proxy');

  http = require('http');

  fs = require('fs');

  utils = require('./utils');

  log = require('./log');

  server = {};

  server.start = function(hem) {
    var app, options;
    app = connect();
    app.use(server.middleware(hem));
    options = hem.options.hem;
    http.createServer(app).listen(options.port, options.host);
    return app;
  };

  server.middleware = function(hem) {
    var app, backend, display, options, pkg, route, statics, value, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _ref3, _ref4;
    backend = connect();
    options = hem.options.hem;
    statics = [];
    _ref = options != null ? options["static"] : void 0;
    for (route in _ref) {
      value = _ref[route];
      statics.push({
        url: route,
        path: value
      });
    }
    _ref1 = hem.apps;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      app = _ref1[_i];
      log.info("> Apply route mappings for application: <green>" + app.name + "</green>");
      _ref2 = app.packages;
      for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
        pkg = _ref2[_j];
        if (options.baseAppRoute) {
          pkg.route = utils.cleanRoute(options.baseAppRoute, pkg.route);
        }
        log.info(" - Mapping route  <yellow>" + pkg.route + "</yellow> to <yellow>" + pkg.target + "</yellow>");
      }
      _ref3 = app["static"];
      for (_k = 0, _len2 = _ref3.length; _k < _len2; _k++) {
        route = _ref3[_k];
        if (options.baseAppRoute) {
          route.url = utils.cleanRoute(options.baseAppRoute, route.url);
        }
        log.info(" - Mapping static <yellow>" + route.url + "</yellow> to <yellow>" + route.path + "</yellow>");
        statics.push(route);
      }
    }
    for (_l = 0, _len3 = statics.length; _l < _len3; _l++) {
      route = statics[_l];
      if (!fs.existsSync(route.path)) {
        log.errorAndExit("The resource <yellow>" + route.path + "</yellow> not found for static mapping <yellow>" + route.url + "</yellow>");
      }
      if (fs.lstatSync(route.path).isDirectory()) {
        backend.use(route.url, checkForRedirect());
        backend.use(route.url, connect["static"](route.path));
      } else {
        backend.use(route.url, (function(route) {
          return function(req, res) {
            return fs.readFile(route.path, function(err, data) {
              if (err) {
                res.writeHead(404);
                return res.end(JSON.stringify(err));
              } else {
                res.writeHead(200);
                return res.end(data);
              }
            });
          };
        })(route));
      }
    }
    _ref4 = options.proxy;
    for (route in _ref4) {
      value = _ref4[route];
      display = "" + value.host + ":" + (value.port || 80) + value.path;
      log.info("> Proxy requests <yellow>" + route + "</yellow> to <yellow>" + display + "</yellow>");
      backend.use(route, createRoutingProxy(value));
    }
    return function(req, res, next) {
      var str, url, _len4, _m, _ref5, _ref6;
      url = ((_ref5 = require("url").parse(req.url)) != null ? _ref5.pathname.toLowerCase() : void 0) || "";
      if (url.match(/(\.js|\.css)$/)) {
        _ref6 = hem.apps;
        for (_m = 0, _len4 = _ref6.length; _m < _len4; _m++) {
          app = _ref6[_m];
          if (pkg = app.isMatchingRoute(url)) {
            str = pkg.build();
            res.charset = 'utf-8';
            res.setHeader('Content-Type', mime.lookup(pkg.target));
            res.setHeader('Content-Length', Buffer.byteLength(str));
            res.end((req.method === 'HEAD' && null) || str);
            return;
          }
        }
      }
      return backend.handle(req, res, next);
    };
  };

  checkForRedirect = function() {
    return function(req, res, next) {
      var pathname;
      pathname = require("url").parse(req.originalUrl).pathname;
      if (req.url === "/" && !utils.endsWith(pathname, "/")) {
        pathname += '/';
        res.statusCode = 301;
        res.setHeader('Location', pathname);
        return res.end('Redirecting to ' + pathname);
      } else {
        return next();
      }
    };
  };

  createRoutingProxy = function(options) {
    var proxy;
    proxy = new httpProxy.RoutingProxy();
    options.path || (options.path = "");
    options.port || (options.port = 80);
    options.patchRedirect || (options.patchRedirect = true);
    if (options.patchRedirect) {
      proxy.once("start", function(req, res) {
        var returnHost;
        returnHost = req.headers.host;
        return patchServerResponseForRedirects(options.host, returnHost);
      });
    }
    return function(req, res, next) {
      req.url = "" + options.path + req.url;
      return proxy.proxyRequest(req, res, options);
    };
  };

  patchServerResponseForRedirects = function(fromHost, returnHost) {
    var writeHead;
    writeHead = http.ServerResponse.prototype.writeHead;
    return http.ServerResponse.prototype.writeHead = function(status) {
      var headers, newLocation, oldLocation;
      if (status === 301 || status === 302) {
        headers = this._headers;
        oldLocation = new RegExp(":\/\/" + fromHost + ":?[0-9]*");
        newLocation = "://" + returnHost;
        headers.location = headers.location.replace(oldLocation, newLocation);
      }
      return writeHead.apply(this, arguments);
    };
  };

  module.exports = server;

}).call(this);
