// Generated by CoffeeScript 2.7.0
(function() {
  var Hem, application, argv, compilers, events, fs, help, log, optimist, path, server, testing, utils, versioning,
    indexOf = [].indexOf;

  fs = require('fs');

  path = require('path');

  optimist = require('optimist');

  // ------- Commandline arguments
  argv = optimist.usage(['usage:\nhem COMMAND', '    server  :start a dynamic development server', '    build   :serialize application to disk', '    watch   :build & watch disk for changes', '    test    :build and run tests', '    clean   :clean compiled targets', '    version :version the application files', '    check   :check slug file values'].join("\n")).alias('p', 'port').describe('p', ':hem server port').alias('h', 'host').describe('h', ':hem server host').alias('c', 'compress').describe('c', ':all compilations are compressed/minified').alias('w', 'watch').describe('w', ':watch files when running tests').alias('s', 'slug').describe('s', ':run hem using a specified slug file').alias('n', 'nocolors').describe('n', ':disable color in console output').alias('v', 'verbose').describe('v', ':make hem more talkative(verbose)').alias('g', 'grep').describe('g', ':only run specific modules during test').alias('r', 'runner').describe('r', ':override the default test runner').argv;

  // set command and targets properties
  argv.command = argv._[0];

  argv.targets = argv._.slice(1);

  if (!!argv.nocolors) {
    // disable colors
    require("sty").disable();
  }

  // turn on/off verbose logging
  log = require('./log');

  log.VERBOSE = argv.v = !!argv.v;

  // ------- perform requires
  utils = require('./utils');

  compilers = require('./compilers');

  server = require('./server');

  testing = require('./test');

  application = require('./package');

  versioning = require('./versioning');

  events = require('./events');

  // supply argv object to module
  compilers.argv = argv;

  application.argv = argv;

  // ------- Global Functions
  help = function() {
    var ref;
    log("<b>HEM</b> Version: <green>" + ((ref = require('../package.json')) != null ? ref.version : void 0) + "</green>\n");
    optimist.showHelp();
    return process.exit();
  };

  Hem = (function() {
    // ------- Hem Class
    class Hem {
      static exec(command, options) {
        return (new this(options)).exec(command);
      }

      static middleware(slug) {
        var hem;
        hem = new Hem(slug);
        return server.middleware(hem);
      }

      // ------- Constructor
      constructor(options) {
        var base, base1, base2, base3, base4, base5, base6, config, name, ref, slug;
        // handle slug file options
        switch (typeof options) {
          case "string":
            slug = options;
            break;
          case "object":
            this.options = options;
            break;
          default:
            slug || (slug = argv.slug || 'slug');
        }
        if (slug) {
          // if given a slug file, attempt to load
          this.options = this.readSlug(slug);
        }
        // make sure some defaults are present
        (base = this.options).hem || (base.hem = {});
        (base1 = this.options.hem).port || (base1.port = 9294);
        (base2 = this.options.hem).host || (base2.host = "localhost");
        // test defaults
        (base3 = this.options.hem).test || (base3.test = {});
        (base4 = this.options.hem.test).runner || (base4.runner = "karma");
        (base5 = this.options.hem.test).reporters || (base5.reporters = "progress");
        (base6 = this.options.hem.test).frameworks || (base6.frameworks = "jasmine");
        if (argv.port) {
          // allow overrides from command line
          this.options.hem.port = argv.port;
        }
        if (argv.host) {
          this.options.hem.host = argv.host;
        }
        if (argv.runner) {
          this.options.hem.test.runner = argv.runner;
        }
        ref = this.options;
        // setup applications from options/slug
        for (name in ref) {
          config = ref[name];
          if (name === "hem" || typeof config === 'function') {
            continue;
          }
          this.allApps.push(application.create(name, config, this, argv));
        }
      }

      // ------- Command Functions
      server() {
        var app, i, len, ref, results, value;
        value = `http://${this.options.hem.host || "*"}:${this.options.hem.port}`;
        log(`Starting Server at <blue>${value}</blue>`);
        app = server.start(this);
        events.emit("server", app);
        ref = this.apps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          // make sure watch is going to recompile immediately
          results.push(app.watch());
        }
        return results;
      }

      clean() {
        var app, i, len, ref, results;
        ref = this.apps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          results.push(app.unlink());
        }
        return results;
      }

      build() {
        this.clean();
        return this.buildApps();
      }

      version() {
        var app, i, len, ref, results;
        ref = this.apps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          results.push(app.version());
        }
        return results;
      }

      watch() {
        var app, i, len, ref, results;
        this.buildApps();
        ref = this.apps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          results.push(app.watch());
        }
        return results;
      }

      test() {
        var testOptions;
        this.build();
        // set test options
        testOptions = this.options.hem.tests || {};
        testOptions.basePath || (testOptions.basePath = this.home);
        // check for watch mode
        if (argv.watch) {
          this.watch();
          testOptions.singleRun = false;
        } else {
          testOptions.singleRun = true;
        }
        // run tests
        return testing.run(this.apps, testOptions);
      }

      check() {
        var app, i, inspect, len, printOptions, ref, results;
        printOptions = {
          showHidden: false,
          colors: !argv.nocolors,
          depth: null
        };
        inspect = require('util').inspect;
        // print hem configuration
        log("> Configuration for <green>hem</green>:");
        console.log(inspect(this.options.hem, printOptions));
        log("");
        ref = this.apps;
        // print app configurations
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          log(`> Configuration values for <green>${app.name}</green>:`);
          console.log(inspect(app, printOptions));
          results.push(log(""));
        }
        return results;
      }

      exec(command = argv.command) {
        var base;
        if (!this[command]) {
          return help();
        }
        // reset the apps list based on command line args
        this.apps = this.getTargetApps();
        if (typeof (base = this.slug).custom === "function") {
          base.custom(this);
        }
        // hope this works :o)
        return this[command]();
      }

      // ------- Private Functions
      readSlug(slug) {
        var error, slugPath;
        // first make sure slug file exists
        slugPath = path.resolve(slug);
        try {
          slugPath = require.resolve(slugPath);
        } catch (error1) {
          error = error1;
          log.errorAndExit(`Couldn't find slug file ${path.dirname(slugPath)}`);
        }
        // set home directory to slug directory
        this.home = path.dirname(slugPath);
        try {
          // next try to require
          delete require.cache[slugPath];
          this.slug = require(slugPath);
        } catch (error1) {
          error = error1;
          log.errorAndExit(`Couldn't load slug file ${slugPath}: ` + error.message);
        }
        // return config portion of slug file
        return this.slug.config || this.slug;
      }

      getTargetApps(targets = argv.targets) {
        var app, i, len, ref, ref1, results, targetAll;
        targetAll = targets.length === 0;
        ref = this.allApps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          if ((ref1 = app.name, indexOf.call(targets, ref1) >= 0) || targetAll) {
            results.push(app);
          }
        }
        return results;
      }

      buildApps() {
        var app, i, len, ref, results;
        ref = this.apps;
        results = [];
        for (i = 0, len = ref.length; i < len; i++) {
          app = ref[i];
          results.push(app.build());
        }
        return results;
      }

      module(name) {
        switch (name) {
          case "compilers":
            return compilers;
          case "events":
            return events;
          case "reporters":
            return testing.phantom.reporters;
          case "versioning":
            return versioning;
          case "log":
            return log;
          default:
            throw new Error(`Unknown module name ${name}`);
        }
      }

    };

    // ------- instance variables

    // emtpy options map and applications list
    Hem.prototype.options = {};

    Hem.prototype.apps = [];

    Hem.prototype.allApps = [];

    Hem.prototype.home = process.cwd();

    return Hem;

  }).call(this);

  module.exports = Hem;

}).call(this);
