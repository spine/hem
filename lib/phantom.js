// Generated by CoffeeScript 2.7.0
(function() {
  var err, jasmine_checkTestResults, jasmine_parseTestResults, log, phantom, reporters, run, waitFor;

  log = require("./log");

  try {
    // attempt to load the phantom module, which is an optional
    // dependency. If not available return an empty object
    phantom = require('phantom');
  } catch (error) {
    err = error;
    phantom = void 0;
  }

  // ------- Test Result Formatters

  // TODO: need to make this work with mocha at some point
  reporters = {
    errorsOnly: function(el, level, strong) {
      var desc, indent, tick;
      indent = function(level) {
        var i, j, ref, ret;
        ret = '';
        for (i = j = 0, ref = level; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          ret = ret + '  ';
        }
        return ret;
      };
      desc = function(el) {
        return $(el).find('> a.description')[0].text;
      };
      tick = function(el) {
        if ($(el).is('.passed')) {
          return '✓ ';
        } else {
          return '✖ ';
        }
      };
      if (typeof el === 'number') {
        return "Passed: " + el + ", Failed: " + level;
      } else if (!$(el).is(".passed")) {
        return indent(level) + tick(el) + desc(el);
      }
    },
    silent: function() {
      return "";
    },
    passOrFail: function(el, level, strong) {
      if (typeof el === 'number') {
        return "Passed: " + el + ", Failed: " + level;
      }
    },
    formatColors: function(el, level, strong) {
      var desc, indent, results, tick;
      indent = function(level) {
        var i, j, ref, ret;
        ret = '';
        for (i = j = 0, ref = level; (0 <= ref ? j <= ref : j >= ref); i = 0 <= ref ? ++j : --j) {
          ret = ret + '  ';
        }
        return ret;
      };
      tick = function(el) {
        if ($(el).is('.passed')) {
          return '\x1B[32m✓\x1B[0m';
        } else {
          return '\x1B[31m✖';
        }
      };
      desc = function(el, strong = false) {
        var ret;
        ret = $(el).find('> a.description');
        return ret = strong && '\x1B[1m' + ret[0].text || ret[0].text;
      };
      // display final results
      if (typeof el === 'number') {
        results = "-------------------------------------\n";
        results += "\x1B[32m✓\x1B[0m\x1B[1m Passed: \x1B[0m" + el;
        if (level > 0) {
          results += "\n\x1B[31m✖ \x1B[0m\x1B[1mFailed: \x1B[0m" + level;
        }
        return results;
      } else {
        // format output
        return '\x1B[1m' + indent(level) + tick(el) + ' ' + desc(el, strong);
      }
    }
  };

  // ------- Wait for certain page elements to become visible
  waitFor = (function() {
    var getTime;
    getTime = function() {
      return (new Date()).getTime();
    };
    return function(test, doIt, duration) {
      var finish, int, looop, start;
      duration || (duration = 60000);
      start = getTime();
      finish = start + duration;
      int = void 0;
      // looop function to call using setInterval
      looop = function() {
        var testCallback, time, timeout;
        time = getTime();
        timeout = time >= finish;
        // callback for page evaluate that receives results
        testCallback = function(condition) {
          // No more time or condition fulfilled
          if (condition) {
            clearInterval(int);
            doIt(time - start);
          }
          // THEN, no moretime but condition unfulfilled
          if (timeout && !condition) {
            clearInterval(int);
            return doIt(0, "Timeout for page condition.");
          }
        };
        // perform the test evaluation
        return test(testCallback);
      };
      // the intervale number
      return int = setInterval(looop, 1000);
    };
  })();

  // ------- Jasmine Functions
  jasmine_parseTestResults = function(report) {
    var failed, passed, printSpecs, printSuites;
    // parameters need to be passed in as a simple string so we
    // need to turn report back into a real javascript function
    eval("report = " + report);
    // handle looping over suites
    printSuites = function(root, level) {
      level || (level = 0);
      return $(root).find('div.suite').each(function(i, el) {
        var output;
        output = report(el, level, true);
        if ($(el).parents('div.suite').length === level) {
          if (output) {
            window.callPhantom(output);
          }
          printSpecs(el, level + 1);
        }
        return printSuites(el, level + 1);
      });
    };
    // handle looping over specs
    printSpecs = function(root, level) {
      level || (level = 0);
      return $(root).find('> .specSummary').each(function(i, el) {
        var output;
        output = report(el, level);
        if (output) {
          return window.callPhantom(output);
        }
      });
    };
    // our starting point
    printSuites($('div.jasmine_reporter'));
    // handle results
    failed = document.body.querySelectorAll('div.jasmine_reporter div.specSummary.failed').length;
    passed = document.body.querySelectorAll('div.jasmine_reporter div.specSummary.passed').length;
    window.callPhantom(report(passed, failed));
    return {
      // return results, these will be eventually passed to the
      // the callback function that was provided initially.
      passed: passed,
      failed: failed
    };
  };

  jasmine_checkTestResults = function(page) {
    return function(checkComplete) {
      var isCheckComplete;
      isCheckComplete = function() {
        var ref;
        return (ref = document.querySelector(".duration")) != null ? ref.innerText : void 0;
      };
      return page.evaluate(isCheckComplete, checkComplete);
    };
  };

  // ------- Public Functions
  run = function(filepath, options, callback, port = 12300) {
    log.info(`Testing file <yellow>${filepath}</yellow> on port <blue>${port}</blue>`);
    return phantom.create(function(ph) {
      return ph.createPage(function(page) {
        // print console.log output from the webpage
        page.set('onConsoleMessage', function(msg) {
          return console.log(msg);
        });
        // page callback, kind of a hackish way to only allow our phantom
        // script to make use of console.log so we only see test results.
        page.set('onCallback', function(msg) {
          if (msg) {
            return console.log(msg);
          }
        });
        // open the filepath and beging tests
        return page.open(filepath, function(status) {
          var checkTestResults, complete, evalTestResults, parseTestResults, reporter;
          if (status !== "success") {
            ph.exit();
            callback({
              error: "Cannot open URL"
            });
            return;
          }
          // assign the appropiate framework functions
          checkTestResults = jasmine_checkTestResults(page);
          parseTestResults = jasmine_parseTestResults;
          // function to call upon completion of test parsing
          complete = function(results) {
            ph.exit();
            return typeof callback === "function" ? callback(results) : void 0;
          };
          // ability to request different type of outputs, default to formatColors
          reporter = reporters[options.output];
          // function to call the parsing function, along with callback once
          // everything is complete and the reporter instance that is passed
          // to the parseTestResults function. If time parameter is 0 then 
          // assume that the tests never fully completed.
          evalTestResults = function(time, err) {
            if (err) {
              return complete({
                error: err
              });
            } else {
              return page.evaluate(parseTestResults, complete, new String(reporter));
            }
          };
          // wait for indication tests are done and then
          // eval/print the test results, all passing, yay!
          return waitFor(checkTestResults, evalTestResults);
        });
      });
    }, {
      port: port
    });
  };

  // ------- Exports

  // check to make sure phantom is loaded correctly and if
  // not then display an appropiate error message...
  if (phantom) {
    module.exports.run = run;
  } else {
    module.exports.run = function() {
      return log.error("Unable to require('phantom') npm module...");
    };
  }

  // export reporters object to allow custom code
  module.exports.reporters = reporters;

}).call(this);
