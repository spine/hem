// Generated by CoffeeScript 2.3.1
(function() {
  var compileCoffeescript, compilers, cs, fs, lmCache, log, path, projectPath, requireLocalModule;

  fs = require('fs');

  path = require('path');

  log = require('./log');

  compilers = {};

  lmCache = {};

  // argv is set when hem first loads up
  compilers.argv = {};

  // Load the modules from the project directory (instead of from the hem
  // node_modules). This allows a lot of the different javascript/css pre
  // compilers to be installed in the project vs having to be included with
  // the hem package.

  // setup project path
  projectPath = path.resolve(process.cwd());

  // TODO: test to make sure the project path contains a node_modules folder??
  // TODO: provide compiler options in slug file!

  // helper fuction to perform load/caching of modules
  requireLocalModule = function(localModule, _path) {
    var error, modulePath, relativePath;
    modulePath = `${projectPath}/node_modules/${localModule}`;
    try {
      return lmCache[localModule] || (lmCache[localModule] = require(modulePath));
    } catch (error1) {
      error = error1;
      relativePath = path.relative(projectPath, _path);
      log.error(`Unable to load <green>${localModule}</green> module to compile <yellow>${relativePath}</yellow>`);
      log.error(`Try to use 'npm install ${localModule}' in your project directory.`);
      if (log.VERBOSE) {
        log.error(error, false);
      }
      return process.exit();
    }
  };

  //#
  //# Basic javascript/css files
  //#
  compilers.js = compilers.css = function(_path) {
    return fs.readFileSync(_path, 'utf8');
  };

  require.extensions['.css'] = function(module, filename) {
    var source;
    source = JSON.stringify(compilers.css(filename));
    return module._compile(`module.exports = ${source}`, filename);
  };

  //#
  //# HTML and Tmpl files
  //#
  compilers.tmpl = function(_path) {
    var content;
    content = fs.readFileSync(_path, 'utf8');
    return `module.exports = ${JSON.stringify(content)};\n`;
  };

  require.extensions['.tmpl'] = function(module, filename) {
    return module._compile(compilers.tmpl(filename), filename);
  };

  compilers.html = function(_path) {
    var content;
    content = fs.readFileSync(_path, 'utf8');
    // remove whitespace
    content = content.replace(/\n/g, "").replace(/[\t ]+\</g, "<").replace(/\>[\t ]+\</g, "><").replace(/\>[\t ]+$/g, ">");
    // export
    return `module.exports = ${JSON.stringify(content)};\n`;
  };

  require.extensions['.html'] = function(module, filename) {
    return module._compile(compilers.html(filename), filename);
  };

  //#
  //# Compile Coffeescript
  //#
  cs = require('coffeescript');

  compilers.coffee = function(_path) {
    return compileCoffeescript(_path, false, this.argv.transpile);
  };

  compilers.litcoffee = function(_path) {
    return compileCoffeescript(_path, true, this.argv.transpile);
  };

  compileCoffeescript = (_path, literate = false, transpile = false) => {
    var coffeeOptions, err;
    try {
      coffeeOptions = {
        filename: _path,
        literate: literate
      };
      if (transpile) {
        coffeeOptions.transpile = {
          presets: ['@babel/env']
        };
      }
      return cs.compile(fs.readFileSync(_path, 'utf8'), coffeeOptions);
    } catch (error1) {
      err = error1;
      err.message = "Coffeescript Error: " + err.message;
      err.path = "Coffeescript Path:  " + _path;
      if (err.location) {
        err.path = err.path + ":" + (err.location.first_line + 1);
      }
      throw err;
    }
  };

  //#
  //# Eco and Jeco Compiler
  //#
  compilers.eco = function(_path) {
    var content, eco, err;
    eco = requireLocalModule('eco', _path);
    try {
      content = eco.precompile(fs.readFileSync(_path, 'utf8'));
    } catch (error1) {
      err = error1;
      err = new Error(err);
      err.message = "eco Error: " + err.message;
      err.path = "eco Path:  " + _path;
      throw err;
    }
    return `var content = ${content};\nmodule.exports = content;`;
  };

  compilers.jeco = function(_path) {
    var content, eco, err;
    eco = requireLocalModule('eco', _path);
    try {
      content = eco.precompile(fs.readFileSync(_path, 'utf8'));
    } catch (error1) {
      err = error1;
      err = new Error(err);
      err.message = "jeco Error: " + err.message;
      err.path = "jeco Path:  " + _path;
      throw err;
    }
    return `module.exports = function(values, data){\n  var $  = jQuery, result = $();\n  values = $.makeArray(values);\n  data = data || {};\n  for(var i=0; i < values.length; i++) {\n    var value = $.extend({}, values[i], data, {index: i});\n    var elem  = $((${content})(value));\n    elem.data('item', value);\n    $.merge(result, elem);\n  }\n  return result;\n};`;
  };

  // require.extensions['.eco'] in eco package contains the function
  require.extensions['.jeco'] = require.extensions['.eco'];

  //#
  //# Pug Compiler
  //#
  compilers.pug = function(_path) {
    var content, ex, pug, source, template;
    pug = requireLocalModule('pug', _path);
    content = fs.readFileSync(_path, 'utf8');
    try {
      template = pug.compileClient(content, {
        filename: _path,
        compileDebug: this.argv.command === "server"
      });
      source = template.toString();
      return `module.exports = ${source};`;
    } catch (error1) {
      ex = error1;
      throw new Error(`${ex} in ${_path}`);
    }
  };

  require.extensions['.pug'] = function(module, filename) {
    return module._compile(compilers.pug(filename), filename);
  };

  //#
  //# Jade Compiler
  //#
  compilers.jade = function(_path) {
    var content, ex, jCompile, jade, source, template;
    jade = requireLocalModule('jade', _path);
    content = fs.readFileSync(_path, 'utf8');
    try {
      // look first for compileClient (starting with jade v1.0.0) and fallback compile if not defined
      jCompile = jade.compileClient || jade.compile;
      template = jCompile(content, {
        filename: _path,
        compileDebug: this.argv.command === "server",
        client: true
      });
      source = template.toString();
      return `module.exports = ${source};`;
    } catch (error1) {
      ex = error1;
      throw new Error(`${ex} in ${_path}`);
    }
  };

  require.extensions['.jade'] = function(module, filename) {
    return module._compile(compilers.jade(filename), filename);
  };

  //#
  //# Stylus Compiler
  //#
  compilers.stylus = function(_path) {
    var content, result, stylus;
    stylus = requireLocalModule('stylus', _path);
    content = fs.readFileSync(_path, 'utf8');
    result = '';
    stylus(content).set('include css', true).include(path.dirname(_path)).render(function(err, css) {
      if (err) {
        throw err;
      }
      return result = css;
    });
    return result;
  };

  require.extensions['.styl'] = function(module, filename) {
    var source;
    source = JSON.stringify(compilers.stylus(filename));
    return module._compile(`module.exports = ${source}`, filename);
  };

  //#
  //# Less Compiler
  //#
  compilers.less = function(_path) {
    var content, less, result;
    less = requireLocalModule('less', _path);
    content = fs.readFileSync(_path, 'utf8');
    result = '';
    less.render(content, function(err, css) {
      if (err) {
        throw err;
      }
      return result = css;
    });
    return result;
  };

  require.extensions['.less'] = function(module, filename) {
    var source;
    source = JSON.stringify(compilers.less(filename));
    return module._compile(`module.exports = ${source}`, filename);
  };

  //#
  //# Environment Compiler
  //#

  // This creates a javascript module based off key values found in environment
  // variables or in the package.json file. Usefule for inserting build info
  // that would come frome a CI server (like jenkins)
  compilers.env = function(_path) {
    var content, envhash, key, packjson;
    content = fs.readFileSync(_path, 'utf8');
    envhash = JSON.parse(content);
    packjson = JSON.parse(fs.readFileSync(path.join(projectPath, 'package.json'), 'utf8'));
// loop over values in file
    for (key in envhash) {
      if (packjson[key]) {
        envhash[key] = packjson[key];
      }
      if (process.env[key]) {
        envhash[key] = process.env[key];
      }
    }
    // return javascript module
    return "module.exports = " + JSON.stringify(envhash);
  };

  module.exports = compilers;

}).call(this);
