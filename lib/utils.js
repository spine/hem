// Generated by CoffeeScript 1.7.0
(function() {
  var clean, extend, flatten, fs, isWin, path, tmplCache, utils,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __slice = [].slice;

  path = require('path');

  fs = require('fs-extra');

  utils = {};

  isWin = !!require('os').platform().match(/^win/);

  utils.flatten = flatten = function(array, results) {
    var item, _i, _len;
    if (results == null) {
      results = [];
    }
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      item = array[_i];
      if (Array.isArray(item)) {
        flatten(item, results);
      } else if (item) {
        results.push(item);
      }
    }
    return results;
  };

  utils.arrayToString = function(value) {
    var line, result, _i, _len;
    if (Array.isArray(value)) {
      result = "";
      for (_i = 0, _len = value.length; _i < _len; _i++) {
        line = value[_i];
        result += line + "\n";
      }
      return result;
    } else {
      return value;
    }
  };

  utils.removeDuplicateValues = function(array) {
    var newArray, value, _i, _len;
    newArray = [];
    for (_i = 0, _len = array.length; _i < _len; _i++) {
      value = array[_i];
      if (__indexOf.call(newArray, value) < 0) {
        newArray.push(value);
      }
    }
    return newArray;
  };

  utils.toArray = function(value) {
    if (value == null) {
      value = [];
    }
    if (Array.isArray(value)) {
      return value;
    } else {
      return [value];
    }
  };

  utils.startsWith = function(str, value) {
    return (str != null ? str.slice(0, value.length) : void 0) === value;
  };

  utils.endsWith = function(str, value) {
    return (str != null ? str.slice(-value.length) : void 0) === value;
  };

  utils.extend = extend = function(a, b) {
    var x;
    for (x in b) {
      if (typeof b[x] === 'object' && !Array.isArray(b[x])) {
        a[x] || (a[x] = {});
        extend(a[x], b[x]);
      } else {
        a[x] = b[x];
      }
    }
    return a;
  };

  utils.loadAsset = function(asset) {
    return require("../assets/" + asset);
  };

  utils.copyFile = function(from, to) {
    var BUF_LENGTH, bytesRead, fdr, fdw, pos, _buff;
    fs.createFileSync(to);
    BUF_LENGTH = 64 * 1024;
    _buff = new Buffer(BUF_LENGTH);
    fdr = fs.openSync(from, 'r');
    fdw = fs.openSync(to, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
      bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
      fs.writeSync(fdw, _buff, 0, bytesRead);
      pos += bytesRead;
    }
    fs.closeSync(fdr);
    return fs.closeSync(fdw);
  };

  utils.isDirectory = function(dir) {
    var e, stats;
    try {
      stats = fs.lstatSync(dir);
      return stats.isDirectory();
    } catch (_error) {
      e = _error;
      return false;
    }
  };

  utils.requireDirectory = function(directory) {
    directory = path.resolve(directory);
    return fs.readdirSync(directory).reduce(function(hash, file) {
      var file_extension, file_name, file_path, key, value, _ref;
      file_path = path.join(directory, file);
      file_name = file.substring(0, file.lastIndexOf('.'));
      file_extension = file.substring(file.lastIndexOf('.'));
      if (file_extension !== '.coffee' && file_extension !== '.js') {
        return hash;
      } else if (file_name === 'index' && typeof require(file_path) === 'object') {
        _ref = require(file_path);
        for (key in _ref) {
          value = _ref[key];
          hash[key] = value;
        }
      } else {
        hash[file_name] = require(file_path);
      }
      return hash;
    }, {});
  };

  tmplCache = {};

  utils.tmpl = function(str, data) {
    var fn, template;
    if (!/[\t\r\n% ]/.test(str)) {
      if (tmplCache[str]) {
        fn = tmplCache[str];
      } else {
        template = utils.loadAsset("" + str + ".tmpl");
        fn = utils.tmpl(template);
      }
    } else {
      str = str.split("'").join("\\'").split("\n").join("\\n").replace(/<%([\s\S]*?)%>/mg, function(m, t) {
        return '<%' + t.split("\\'").join("'").split("\\n").join("\n") + '%>';
      }).replace(/<%=(.+?)%>/g, "',$1,'").split("<%").join("');").split("%>").join("p.push('");
      fn = new Function("obj", "var p=[]\nvar print = function(){ p.push.apply(p,arguments); };\nwith(obj){\n  p.push('" + str + "');\n}\nreturn p.join('');");
    }
    return data && fn(data) || fn;
  };

  clean = function(values, sep, trimStart) {
    var regexp, result, value, _i, _len;
    if (trimStart == null) {
      trimStart = false;
    }
    result = "";
    for (_i = 0, _len = values.length; _i < _len; _i++) {
      value = values[_i];
      if (value) {
        result = result + sep + value;
      }
    }
    regexp = new RegExp("" + sep + "+", "g");
    result = result.replace(regexp, sep);
    if (trimStart && utils.startsWith(result, sep)) {
      result = result.slice(sep.length);
    }
    if (utils.endsWith(result, sep)) {
      result = result.slice(0, -sep.length);
    }
    return result;
  };

  utils.cleanPath = function() {
    var cleanPath, paths, result;
    paths = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    result = clean(paths, path.sep, true);
    if (isWin || true) {
      cleanPath = new RegExp(/\//g);
      result = result.replace(cleanPath, path.sep);
    }
    return result;
  };

  utils.cleanRoute = function() {
    var routes;
    routes = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return clean(routes, "/");
  };

  module.exports = utils;

}).call(this);
