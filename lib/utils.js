// Generated by CoffeeScript 2.7.0
(function() {
  var clean, extend, flatten, fs, isWin, path, tmplCache, utils,
    indexOf = [].indexOf;

  path = require('path');

  fs = require('fs-extra');

  utils = {};

  // check for windows :o(...
  isWin = !!require('os').platform().match(/^win/);

  utils.flatten = flatten = function(array, results = []) {
    var i, item, len;
    for (i = 0, len = array.length; i < len; i++) {
      item = array[i];
      if (Array.isArray(item)) {
        flatten(item, results);
      } else if (item) {
        results.push(item);
      }
    }
    return results;
  };

  utils.arrayToString = function(value) {
    var i, len, line, result;
    if (Array.isArray(value)) {
      result = "";
      for (i = 0, len = value.length; i < len; i++) {
        line = value[i];
        result += line + "\n";
      }
      return result;
    } else {
      return value;
    }
  };

  utils.removeDuplicateValues = function(array) {
    var i, len, newArray, value;
    newArray = [];
    for (i = 0, len = array.length; i < len; i++) {
      value = array[i];
      if (indexOf.call(newArray, value) < 0) {
        newArray.push(value);
      }
    }
    return newArray;
  };

  utils.toArray = function(value = []) {
    if (Array.isArray(value)) {
      return value;
    } else {
      return [value];
    }
  };

  utils.startsWith = function(str, value) {
    return (str != null ? str.slice(0, value.length) : void 0) === value;
  };

  utils.endsWith = function(str, value) {
    return (str != null ? str.slice(-value.length) : void 0) === value;
  };

  utils.extend = extend = function(a, b) {
    var x;
    for (x in b) {
      if (typeof b[x] === 'object' && !Array.isArray(b[x])) {
        a[x] || (a[x] = {});
        extend(a[x], b[x]);
      } else {
        a[x] = b[x];
      }
    }
    return a;
  };

  utils.loadAsset = function(asset) {
    return require("../assets/" + asset);
  };

  utils.copyFile = function(from, to) {
    var BUF_LENGTH, _buff, bytesRead, fdr, fdw, pos;
    // make sure target files exists
    fs.createFileSync(to);
    // constants
    BUF_LENGTH = 64 * 1024;
    _buff = new Buffer(BUF_LENGTH);
    // perform copy
    fdr = fs.openSync(from, 'r');
    fdw = fs.openSync(to, 'w');
    bytesRead = 1;
    pos = 0;
    while (bytesRead > 0) {
      bytesRead = fs.readSync(fdr, _buff, 0, BUF_LENGTH, pos);
      fs.writeSync(fdw, _buff, 0, bytesRead);
      pos += bytesRead;
    }
    fs.closeSync(fdr);
    return fs.closeSync(fdw);
  };

  utils.isDirectory = function(dir) {
    var e, stats;
    try {
      stats = fs.lstatSync(dir);
      return stats.isDirectory();
    } catch (error) {
      e = error;
      return false;
    }
  };

  // ------ Simple templating function

  // Simple JavaScript Templating
  // John Resig - http://ejohn.org/ - MIT Licensed
  tmplCache = {};

  utils.tmpl = function(str, data) {
    var fn, template;
    // Figure out if we're getting a template, or if we need to
    // load the template - and be sure to cache the result.
    if (!/[\t\r\n% ]/.test(str)) {
      if (tmplCache[str]) {
        fn = tmplCache[str];
      } else {
        // load file
        template = utils.loadAsset(`${str}.tmpl`);
        fn = utils.tmpl(template);
      }
    } else {
      // Convert the template into pure JavaScript
      str = str.split("'").join("\\'").split("\n").join("\\n").replace(/<%([\s\S]*?)%>/mg, function(m, t) {
        return '<%' + t.split("\\'").join("'").split("\\n").join("\n") + '%>';
      }).replace(/<%=(.+?)%>/g, "',$1,'").split("<%").join("');").split("%>").join("p.push('");
      // Generate a reusable function that will serve as a template
      fn = new Function("obj", `var p=[]
var print = function(){ p.push.apply(p,arguments); };
with(obj){
  p.push('${str}');
}
return p.join('');`);
    }
    // Provide some basic currying to the user
    return data && fn(data) || fn;
  };

  // ------ Formatting urls and folder paths
  clean = function(values, sep, trimStart = false) {
    var i, len, regexp, result, value;
    result = "";
    for (i = 0, len = values.length; i < len; i++) {
      value = values[i];
      if (value) {
        result = result + sep + value;
      }
    }
    // clean duplicate sep
    regexp = new RegExp(`${sep}+`, "g");
    result = result.replace(regexp, sep);
    // trim the starting path sep if there is one
    if (trimStart && utils.startsWith(result, sep)) {
      result = result.slice(sep.length);
    }
    // make sure doesn't end in sep
    if (utils.endsWith(result, sep)) {
      result = result.slice(0, -sep.length);
    }
    return result;
  };

  utils.cleanPath = function(...paths) {
    var cleanPath, result;
    result = clean(paths, path.sep, true);
    // deal with windows paths :o(...
    if (isWin || true) {
      cleanPath = new RegExp(/\//g);
      result = result.replace(cleanPath, path.sep);
    }
    return result;
  };

  utils.cleanRoute = function(...routes) {
    return clean(routes, "/");
  };

  module.exports = utils;

}).call(this);
